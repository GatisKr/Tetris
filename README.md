# Tetris
Classic Tetris game built with Pygame. Detailed game building tutorial is available here https://youtu.be/nF_crEtmpBo
Below is the description of key elements for building the game.

# Create Game Loop
1. Event Handling: to check for any events that occur in the game, such as quitting the game, a key pressed on the keyboard, etc. This is done using the Pygame event handling system.
2. Updating positions: to update the positions of all game objects, the blocks, based on the events detected in step 1. 
3. Drawing objects: to draw all the game objects in their new positions on the screen. This step uses the Pygame graphics functions to render the objects in the display.
These three steps allow creting a dynamic and interactive game that responds to user inputs and updates its state accordingly.

# Drawing in Pygame
1. Display Surface. The surface where we see all the game objects. It's like blank Canvas. We can only have one per game. The display surface is created when we call the set_mode() function and it's the object we use when we call the update () function.
2. The Regular Surface. The surface like the display surface that we can draw on it. Another type of blank Canvas. We can have as many surfaces as we want per game. Unlike the Display Surface which we can only have one per game. Regular Surfaces are used in this game to draw text on the display surface. 
3. The Rect. A rectangular area. Rectangles are used for positioning, collision detection and for drawing objects. It has a position and a size. Rects are used for easy manipulation of objects and for easy drawing on a surface.

# The Grid
In Tetris the gameplay area is a grid, consisting of 20 rows and 10 columns. The game pieces, or "tetrominoes", fall down the grid and the player must arrange them to form complete rows without any gaps. We will count the rows from top to bottom and the columns from left to the right, with the top left cell at row 0 and column 0 being the origin. To represent the grid we will use a two-dimensional array which can be inplemented as a list of lists in Python. In our implementation, empty cells will be represented by the value 0. When a tetromino, a block, is permanently placed on the grid by the player, the corresponding cells will be assigned a value reflecting its colour. For example, if we place a red tetromino on the grid, we will assign the value 2 to the cells it covers. Similarly, if we place a yellow block, we will assign the value 4 to its corresponding cells. Each colour has a unique numerical value and since there are 7 different colours in the game, the values used in the 2D array will range from 0 to 7. 0 for an empty cell and 1 to 7 for the colours of the blocks. However, the current block that can still be controlled by the player will not be reflected in the array and will instead be stored and managed separately in the game logic. 

# Create the blocks
Tetris is a game where you have to fit different shapes made out of four tiles. There are seven types of shapes in total called tetrominoes. When game starts, the blocks appear in a certain way. The blocks in Tetris can spin around a point, usually in the middle of one of their tiles. For instance, the T-shaped block rotates around the center tile. The I block and the O block in Tetris rotate differently than the other blocks. The I block rotates around a point, that isn't in the center of a tile, while the O block doesn't appear to rotate at all. To represent the blocks, we imagine a box around each block that's big enough to fit in all four rotation states. The box is divided into a grid and we label the top left cell as the origin (row 0, column 0), just like in the Game Grid. For each of the four rotation state we store which cells are occupied in this grid, not all the cells of the grid. For instace the T-block in Tetris. We draw a box around it and divide it into a grid with 3 rows and 3 columns, making 9 cells in total. However, we only need to store the cells, that the T-block occupies, not the whole grid. If the T-block is in its first state (state 0), we only need to store the values (0, 1), which means that the cell in row 0 and column 1 is occupied. We also need to store the values (1, 0), (1, 1) and (1, 2) for the other occupied cells. We repeat this process for the T-block's remaining three rotation states, storing only the occupied cells for each: state 1 (0, 1), (1, 1), (1, 2), (2, 1), state 2 (1, 0), (1, 1), (1, 2), (2, 1), state 3 (0, 1), (1, 0), (1, 1), (2, 1). This is how we represent all the blocks in Tetris, using this same process for each one. Using the bounding grid approach to represent the blocks has a big advantage: it makes rotating the blocks much easier. To rotate a block, all we need to do is to update a state variable that indicates the current rotation state of the block, and modify the occupied cells stored in the grid accordingly. This means we don't have to calculate the new positions of each tile in the block, which can be complex and time-consuming. Instead, we simply update the occupied cells in the bounding grid, and the game engine takes care of displaying the block in correct rotated state. 

# Inheritance
Inheritance is like passing down traits from parents to children. In Python, it allows us to create a new class that is a modified version of an existing class. The new class, called the child class, will inherit all the attributes and methods of the original class, called the parent class. Then we can add new attributes and methods or override the inherited ones in the child class to customize its behavior. This way we don't have to repeat the same code for similar classes and we can make changes to the parent class that will affect all the child classes. It's like having a template that we can reuse and modify without starting from scratch every time. In this game we have 7 different blocks, but they all share some common properties and behaviours. Instead of creating separate classes for each block and duplicating the same code, we can create a base block class with the shared code and characteristics and then create 7 new classes for each block that inherit from the base class. This means that each of the new classes will automatically have all the properties and behaviors of the base class, without needing to repeat the code. Using inheritance helps to simplify code and make it more efficient. It's actually a simple and powerful feature of object-oriented programming.

# Move the blocks
Tetris game use the grid and on top of that only the occupied positions of a smaller grid, the block-grid, are displayed. The origin for both grids is the top lest corner. If we want to move the block, all we have to do is to move its origin point. For example, let's say the current positin of the block is at the top-lesft corner of the grid, which is at position (0, 0). If we want to move the block 3 columns to the right and 5 rows down, we just need two variables to hold the offset in the x and y axis on the grid. Let's call these variables 'row_offset' and 'column_offset'. To move the block 3 columns to the right and 5 rows down, we would set 'column_offset' and 'row_offset" tp 5. Then, we would simply add these values to the row and column positions of the block's origin point. So the new position of the block's origin point would be at (5, 3). This would move the block 3 columns to the right and 5 rows down on the grid. 

# Game Class
In order to improve code organization and make it easiert to manage in the future, we create a Game class to hold the Grid and Block objects, as well as various methods. The Game class will serve as a container for all the elements of our game such as the grid, the current and next block, and game state. It will also hold methods that manage the game's logic such as updating the block's position, checking for collisions, etc. By centralizing all the game's functionality within this class, it will be easier to understand, maintain and expand upon in the future. Additionally, it will also improve code readability and reduce the risk of bugs be keeping related code together in one place. Overall, creating a Game class will greatly improve the organization and structure of our codebase, making it easier to work with in the future. 

# Implement boundary checking
Since we know that the game grid contains 20 rows and 10 columns, we can simply check the current position of each tile of the block. If any of the tiles has moved outside of the game window, we need to move it back within the boundary of the game window.

# Checking for completed rows
We have to check if a row is full, and when it is, have to clear it and move all the occupied cells above that row, one row down. We will scan every row of the grid from the bottom to the top. We need a variable to hold the number of completed rows. If we find a completed row we will increase the completed variable by 1. Then we will clear the row and check the next row. If it is not completed, we will move the row down by the value the completed variable contains. This procedure works for any number of completed rows. For instance, if we find 2 completed rows: we check the first row, it is completed, so ve increase the completed variable by 1 and we clear the row. Then we check the next row. It is completed, so we increase the completed variable by 1, it is now two, and we clear the row. Next we check the next row, it is not completed, so we have to move this row down by exactly two rows. And with the same procedure we check every row of the grid. 
